package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = expr match {
      case Variable(name) => GetLocal(locals(name))
      case IntLiteral(value) => Const(value)
      case BooleanLiteral(value) => if(value) Const(1) else Const(0)
      case StringLiteral(value) => mkString(value)
      case UnitLiteral() => Const(0)
      case Plus(l, r) => cgExpr(l) <:> cgExpr(r) <:> Add
      case Minus(l, r) => cgExpr(l) <:> cgExpr(r) <:> Sub
      case Times(l, r) => cgExpr(l) <:> cgExpr(r) <:> Mul
      case AmyDiv(l, r) => cgExpr(l) <:> cgExpr(r) <:> Div
      case Mod(l, r) => cgExpr(l) <:> cgExpr(r) <:> Rem
      case LessThan(l, r) => cgExpr(l) <:> cgExpr(r) <:> Lt_s
      case LessEquals(l, r) => cgExpr(l) <:> cgExpr(r) <:> Le_s
      case AmyAnd(l, r) => cgExpr(l) <:> If_i32 <:> cgExpr(r) <:> Else <:> Const(0) <:> End
      case AmyOr(l, r) => cgExpr(l) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(r) <:> End
      case Equals(l, r) => cgExpr(l) <:> cgExpr(r) <:> Eq
      case Concat(l, r) => cgExpr(l) <:> cgExpr(r) <:> Call(concatImpl.name)
      case Not(e) => cgExpr(e) <:> Eqz
      case Neg(e) => Const(0) <:> cgExpr(e) <:> Sub
      case AmyCall(qname, args) =>
        val constr = table.getConstructor(qname)
        if(constr.isDefined) {
          val sig = constr.get
          val mb = lh.getFreshLocal()
          val size = (args.size + 1)*4
          // Store and Shift memoryBoundary by size of constructor
          val c1 = GetGlobal(memoryBoundary) <:> SetLocal(mb) <:> GetGlobal(memoryBoundary) <:> Const(size) <:> Add <:> SetGlobal(memoryBoundary)
          // Store constructor index at old memoryBoundary
          val c2 = GetLocal(mb) <:> Const(sig.index) <:> Store <:> GetLocal(mb)
          c1 <:> c2 <:> args.zipWithIndex.map{ case (arg, i) =>
            Const((i+1)*4) <:> Add <:> cgExpr(arg) <:> Store <:> GetLocal(mb)
          }
        }
        else {
          val sig = table.getFunction(qname).get
          args.map(cgExpr(_)) <:>
          Call(fullName(sig.owner, qname))
        }
      case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)
      case Let(df, value, body) =>
        val local = lh.getFreshLocal()
        val id = df.name
        // Save value in memory and load it in the new local
        GetGlobal(memoryBoundary) <:> cgExpr(value) <:> Store <:> GetGlobal(memoryBoundary) <:> Load <:> SetLocal(local) <:>
        // Shift memoryBoundary by 4
        GetLocal(memoryBoundary) <:> Const(4) <:> Add <:> SetGlobal(memoryBoundary) <:>
        // Compute body with new local
        cgExpr(body)(locals ++ Map(id -> local), lh)
      case Ite(cond, thenn, elze) => cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End
      case Match(scrut, cases) => 
        val localScrut = lh.getFreshLocal()
        
        def matchAndBind(m: Pattern) : (Code, Map[Identifier,Int]) = m match {
          case WildcardPattern() => (Const(1), Map())
          case IdPattern(name) =>
            val local = lh.getFreshLocal()
            (SetLocal(local) <:> Const(1), Map(name -> local))
          case LiteralPattern(lit) => lit match {
            case IntLiteral(value) => (Const(value) <:> Eq, Map())
            case BooleanLiteral(value) => if(value) (Const(1) <:> Eq, Map()) else (Const(0) <:> Eq, Map())
            case StringLiteral(value) => (mkString(value) <:> Eq, Map())
            case UnitLiteral() => (Const(0) <:> Eq, Map())
          }
          case CaseClassPattern(constr, args) => 
            val index = table.getConstructor(constr).get.index
            val local = lh.getFreshLocal()
            val argsCode = args.zipWithIndex.map{ 
              case (arg, i) => 
                val (code, loc) = matchAndBind(arg)
                (GetLocal(local) <:> Const(4*(i+1)) <:> Add <:> Load <:> code,
                    loc)
            }.unzip
            val c2: Code = if(args.isEmpty) Const(1) else argsCode._1.reduce(_ <:> _ <:> And)
            val map: Map[Identifier, Int] = if(argsCode._2.isEmpty) Map() else argsCode._2.reduce(_++_)
            (SetLocal(local) <:> GetLocal(local) <:> 
            Load <:> Const(index) <:> Eq <:> If_i32 <:> c2 <:> Else <:> Const(0) <:> End, map)
        }
        
        def handleCases(cases: List[MatchCase]) : Code = cases match {
          case c :: Nil => 
            val (code, moreLocals) = matchAndBind(c.pat)
            GetLocal(localScrut) <:> code <:> If_i32 <:> cgExpr(c.expr)(locals ++ moreLocals, lh) <:> 
            Else <:> cgExpr(Error(StringLiteral("Match error"))) <:> End
          case c :: rest => 
            val (code, moreLocals) = matchAndBind(c.pat)
            GetLocal(localScrut) <:> code <:> If_i32 <:> cgExpr(c.expr)(locals ++ moreLocals, lh) <:> 
            Else <:> handleCases(rest) <:> End
        }
        
        cgExpr(scrut) <:> SetLocal(localScrut) <:> handleCases(cases)
      
      case Error(msg) => cgExpr(msg) <:> Call(readStringImpl.name) <:> Unreachable
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
